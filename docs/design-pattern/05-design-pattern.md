# 经典 23 种设计模式

设计模式主要是为了应对代码的复杂性，让其满足开闭原则，提高代码的扩展性

### 设计模式要做的事情本质就是`解耦`

- 创建型模式是将创建和使用代码解耦
- 结构型模式是将不同功能代码解耦
- 行为型模式是将不同的行为代码解耦

## 创建型 (Creational Patterns) -- 5 种

- 主要解决`对象的创建`问题，封装复杂的创建过程，解耦对象的创建代码和使用代码

### 1. 单例模式

- 创建全局唯一的对象

### 2. 工厂模式

- 用来创建不同但相关类型的对象(继承同一父类或者接口的一组子类)，由给定的参数来决定创建哪类类型的对象。
- 封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明
- 代码复用：创建代码抽离到独立的工厂类之后可以复用
- 隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象
- 控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁

### 3. 建造者模式

- 用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象

### 4. 原型模式

- 如果对象的创建成本比较大，而同一个类的不同对象之间差别不大，在这种情况下，我们可以利用已有对象(原型)进行复制的方式，来创建新对象

## 结构型 (Structural Patterns) -- 7 种

- 主要解决`类或对象的组合或组装`问题

### 1. 代理模式

- 在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能
- 比如：监控、统计、鉴权、限流、事务、幂等、日志

### 2. 桥接模式

- 第一种理解方式：将抽象和实现解耦，让它们能独立开发
- 第二种理解方式：等同于“组合优于继承”设计原则，这种理解更加通用

### 3. 装饰器模式

- 主要解决继承过于复杂的问题，通过组合来替代继承，给原始类添加增强功能
- 可以对原始类嵌套使用多个装饰器

### 4. 适配器模式

- 适配器提供跟原始类不同的接口，将原本由于接口不兼容而不能一起工作的类可以一起工作

### 5. 门面模式

- 通过封装细粒度的接口，提供组合各个细粒度接口的高层次接口，来提高接口的易用性，或者解决性能、分布式事务等问题

### 6. 组合模式

- 主要是用来处理树形结构数据

### 7. 享元模式

- 被共享的单元，意图是复用对象，节省内存，前提是享元对象是不可变对象

## 行为型 (Behavioral Patterns) -- 11 种

- 主要解决`类或对象之前的交互`问题

### 1. 观察者模式 (Observer Pattern)

- 是将观察者和被观察者的代码解耦

### 2. 模板模式

- 在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现

### 3. 策略模式

- 定义一族算法类，将每个算法分别封装起来，让它们可以互相替换，比如各种排序算法
- 用来解耦策略的定义、创建、使用
- 最常见的场景是用它来避免冗长的 if-else 分支判断

### 4. 职责链模式

- 多个处理器依次处理同一个请求
- 常用来实现过滤器、拦截器

### 5. 迭代器模式

- 用来遍历集合对象

### 6. 状态模式

- 一般用来实现状态机，状态机常用在游戏、工作流引擎系统开发中
- 状态机由三部分组成：状态、事件、动作
- 状态机由三种实现方式：分支逻辑法、查表法、状态模式

### 7. 访问者模式

- 允许一个或者多个操作应用到一组对象上，设计意图是解耦操作和对象本身

### 8. 备忘录模式

- 也叫快照模式，在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态

### 9. 命令模式

- 用来控制命令的执行，比如异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等

### 10. 解释器模式

- 为某个语言定义它的语法

### 11. 中介模式

- 设计思想跟中间层很像，将一组对象之间的交互关系从多对多的网状关系转换成一对多的星状关系
