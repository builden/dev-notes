# 面向对象编程

- 面向对象编程是以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石
- 面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性的编程语言

## 对比面向过程

- 面向过程编程是以过程(可以理解为方法、函数、操作)作为组织代码的基本单元，以数据(可以理解为成员变量、属性)与方法相分离为主要的特点。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能

## 面向对象的四大特性

- JS 不支持封装和继承的特性

### 1. 封装 (Encapsulation)

- 又叫信息隐藏或者数据访问保护
- 类暴露有限的访问接口，授权外部仅能通过类提供的方法来访问内部的信息或者数据
- 对于这个特性，需要编程语言本身提供一定的语法机制(访问权限控制)来支持，如在 C++里的 public, private 关键字等
- 广义的封装还包括：封装类型、封装变化

#### 封装类型

- 在静态语言中，封装类型是通过抽象类和接口来进行的，把对象的真正类型隐藏在抽象类或者接口之后，相比对象的类型，客户更关心对象的行为

#### 封装变化

- 创建型模式的目的就是封装创建对象的变化。要创建一个对象，是一种抽象行为，而具体创建什么对象则是可以变化的
- 结构型模式封装的对象之间的组合关系
- 行为型模式封装的是对象的行为变化
- 通过封装变化的方式，把系统中稳定不变的部分和容易变化的部分隔离开来，在系统的演变过程中，我们只需要替换那些容易变化的部分，如果这部分是已经封装好的，替换起来也相对容易。这可以最大程度地保证程序的稳定性和可扩展性。
- 当我们想办法把程序中变化的部分封装好之后，剩下的即是稳定而可复用的部分了。

#### 封装的意义

1. 如果没有封装，那任何代码都可以访问访问、修改类中的属性，虽然看起来更加灵活，但过度灵活也意味着不可控，属性可以随意被以各种奇葩的方式修改，而且修改逻辑可能散落在代码的各个角落，势必影响代码的可读性、可维护性。
2. 类仅仅通过有限的方法暴露必要的操作，也能提高类的易用性。如果我们把类属性都暴露个类的调用者，调用者想要正确地操作这些属性，就势必要对业务细节有足够的了解，这对调用者来说也是一种负担。

### 2. 抽象 (Abstraction)

- 讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的
- 在面向对象编程中，我们常借助编程语言提供的接口类或者抽象类这两种语法机制，来实现抽象这一特性
- 函数本身其实就是一种抽象，所以“抽象”有时候不被看作面向对象编程的特性之一

#### 抽象的意义

- 上升到思考层面，抽象及封装都是人类处理复杂性的有效手段。在面对复杂系统时，人脑能承受的信息复杂程度是有限的，所以我们必须忽略掉一些非关键性的实现细节。而抽象作为一种只关注功能点不关注实现的设计思想，正好帮我们的大脑过滤掉许多非必要的信息

### 3. 继承 (Inheritance)

- 继承是用来表示类之间的 is-a 关系，比如猫是一种哺乳动物
- 有些语言只支持单继承，如 Java, C#, Ruby 等；有的支持多继承，如 C++, Python, Perl 等

#### 继承的意义

- 最大的好处就是代码复用
- 不过，过度使用继承、继承层次过深过复杂，会导致代码的可读性、可维护性变差。为了了解一个类，不仅要查看这个类的代码，还需要按照继承关系一层层地往上查看“父类、父类的父类...”的代码。还有，子类和父类高度耦合，修改父类的代码，会直接影响到子类

### 4. 多态 (Polymorphism)

- 同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。换句话说，给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的反馈
  > 主人家里养了两只动物，分别是一只鸡和一直鸭，当主人向它们发出“叫”的命令时，鸭会“嘎嘎嘎”地叫，而鸡会“咯咯咯”地叫。这两只动物都会以自己的方式发出叫声。它们同样都是动物，并且可以发出叫声，但根据主人的指令，它们会各自发出不同的叫声。
- 多态背后的思想是将“做什么”和“谁去做以及怎么去做”分离开来，也就是将“不变的事物”与“可能改变的事物”分离开来

```js
// 这个故事中，动物都会叫，这是不变的，但是不同类型的动物具体怎么叫是可变的
// 把不变的部分隔离开来，把可变的部分封装起来，这给予了我们扩展程序的能力
// 相对于修改代码来说，仅仅增加代码就能完成同样的功能，这显然优雅和安全的多

// 不变的部分隔离，动物都会叫
function makeSound(animal) {
  animal.sound();
}

// 把可变的部分封装起来，这里多态性实际上指的是对象的多态性
// 如果未来要增加一条狗，则只需要简单的追加代码就行了，而不用改动makeSound函数
class Duck {
  sound() {
    console.log('ga ga ga');
  }
}
class Chicken {
  sound() {
    console.log('ge ge ge');
  }
}

makeSound(new Duck());
makeSound(new Chicken());
```

- 子类可以替换父类
- 多态最根本的作用就是通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句
  > 在电影拍摄现场，当导演喊出"action"时，主角开始背台词，照明师负责打灯光，后面的群众演员假装中枪倒地，道具师往镜头里撒雪花。在得到同一个消息时，每个对象都知道自己应该做什么。如果不利用对象的多态性，而是用面向过程的方式来编写这一段代码，那么相当于再电影开始拍摄之后，导演每次都要走到每个人面前，确认他们的职业分工(类型)，然后告诉他们要做什么。如果映射到程序中，那么程序中将充斥着条件分支语句。利用对象的多态性，导演在发布消息时，就不必考虑各个对象接到消息后应该做什么。对象应该做什么并不是临时决定的，而是已经事先约定和排练完毕的。每个对象应该做什么，已经成为了该对象的一个方法，被安装在对象的内部，每个对象负责它们自己的行为

#### 实现方式

1. 继承加方法重新
2. 接口类语法
3. duck-typing (Javascript, Python)

```ts
// duck-typing
// test中的代码可以复用
// 增加一种新类型，只需要让新类型实现record方法，提升了可扩展性
class Logger {
  record() {
    console.log('logger record');
  }
}

class DB {
  record() {
    console.log('db record');
  }
}
function test(recorder) {
  recorder.record();
}

const logger = new Logger();
const db = new DB();
test(logger);
test(db);
```

#### 多态的意义

- 多态提高代码的可扩展性和复用性
- 多态是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、基于接口而非实现编程、依赖导致原则、里氏替换原则等等

## 面向过程的贫血模型和面向对象的充血模型

## 鸭子类型(duck typing)

- 通俗的说法：如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子
  > 从前在 Javascript 王国里，有一个国王，他觉得世界上最美妙的声音是鸭子的叫声，于是他召集大臣，要组建一个 1000 只鸭子组成的合唱团。大臣们找遍了全国，终于找到了 999 只鸭子，但是始终还差一只，最后大臣发现有一只非常特别的鸡，它的叫声跟鸭子一模一样，于是这只鸡成为了合唱团的最后一员。
- 这个故事告诉我们，国王要听的只是鸭子的叫声，这个声音的主人到底是鸡还是鸭并不重要。
- 鸭子类型指导我们只关注对象的行为，而不关注对象本身，也就是关注`has-a`，而不是`is-a`

```js
const duck = {
  duckSinging() {
    console.log('ga ga ga');
  },
};
const chicken = {
  duckSinging() {
    console.log('ga ga ga');
  },
};
const choir = []; // 合唱团
function joinChoir(animal) {
  if (animal && typeof animal.duckSinging === 'function') {
    choir.push(animal);
    console.log('joined to choir');
    console.log('the count of choir is', choir.length);
  }
}
joinChoir(duck);
joinChoir(chicken);
```

- 利用 duck-typing 的思想，我们不必借助超类型的帮助，就能轻松的在动态类型语言中实现一个原则`面向接口编程、而不是面向实现编程`
- 例如：一个对象若有 push 和 pop 方法，并且这些方法提供了正确的实现，就可以被当做栈来使用
- 只有当对象能够被相互替换使用，才能体现对象多态性的价值
